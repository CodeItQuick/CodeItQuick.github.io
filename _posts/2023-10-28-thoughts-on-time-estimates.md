---
layout: post
name: Let's Estimate Our Developer Pain
description: Exploring ideas within project and task estimation for development  
image: story_splitting_zombies.png
tags: agile all
---

# Let's Estimate Our Developer Pain

## 1. Introduction
If you bring up a previous late project with really any developer, you'll quickly get a negative response back. The differences
between developer promises and management expectations has caused a divide between the two for a long time. We'll first talk 
about general problems with estimation, then go into some of the benefits of the estimation process, the rewards from doing 
some form of estimation, and finally conclude that further decreasing this mentioned developer/manager divide will be beneficial. 

## 2. The Pain's of Estimation
<img src="/assets/images/zombie_chasm_estimation.webp"  alt="Zombie Leaping Over Chasm"/>  
### **It's A Common Pain Point**
It's very difficult to estimate individual developer tasks, stories, and project timelines. I've always experienced pain
in someone asking for a widget, website, etc. in a given timeline and then not being able to deliver it in the "required"
timeline. As my career progresses this pain has gotten to be less and less, but I don't think better estimates is really
the reason for this. Instead, being better at building software overall, and better communication skills are the reasons.

### **Minimizing The Pain**
I think the goal of estimation overall is to improve customer satisfaction by better managing expectations. Now is this
the right viewpoint for delivering software, I'm not so sure. Showing continual progress in the development of the software
is probably the most impressive thing a software developer can do. Still, there is major pain in time estimation for developers.
Missed hard deadlines being probably the biggest pain point, so what are some ways we can minimize this pain, beyond just
"be a better developer".

## 3. Solutions Resulting From Estimation
<img src="/assets/images/zombie_engineer_solving_complex.webp"  alt="Zombie Engineer Solving Problem" height="512" width="512" />  
### **Beyond Our Control**
The factors we cannot control can be the most discouraging, but I think in this case it's not so bad. A task that is 
repetitive and routine, not complex, and standardized would be easy to estimate. If we added on top of this 
repetitive task a significant amount of historical data, we could accurately estimate with some error bars how long it 
will take. Unfortunately, the picture I just painted more readily resembles an old-fashioned car assembly line than 
anything we'll see in a developers in-progress lane. 

### **The Ideal Task**
If we split tasks so that one blocks another, this is going to slow down development. We have essentially turned what
could be agile development of independent elements, into waterfall development of progress steps. Ideally, we want small
PR's that are easy to review and merge in, and the work to be done as independently as possible so we can parallelize tasks. 
Making sure the ask is well-defined will further help the developer get to work when needed on each task.

### **Complicating Factors**
If what we are working on is complex and novel, that is going to bring a number of challenges. If the task requires many
moving parts, breaking these down by using techniques like the Makoto Method will be productive. If the project is somehow
novel or innovative, then by its nature it will be all new to us, and well, everyone. If we have to learn a lot to complete
the project, I often find it useful to go off and learn those technologies or learnings on my own before applying them
to the project. Creative tasks are also very difficult, and perhaps trying to take the coding out of the creativity is the answer
here, but really I've never found an easy way to minimize this as far as a project risk goes. 

### **Scope, Uncertainty, And Shifting Priorities**
Finally, we should minimize project risk or uncertainty. A typical mitigation strategy would be using familiar technologies 
to us, rather than new technologies that require the developer to go off and learn a bunch of concepts. We have to avoid 
tasks that shift in their goals, or lack the clarity needed to begin the work. This increases the likelihood of unnecessary 
rework. 

### **Collaboration Issues**
There are challenges inherent in collaboration, especially with external parties. So we have to have these external customer
meetings preferable upfront, and often during the project to fully understand the customer request. High collaboration needs
during the project can be the result of not properly breaking up the tasks into independent chunks, where developers are
not blocking each other's work.

## 4. Rewards: Benefits of Estimation
<img src="/assets/images/zombie_gold_riches.webp"  alt="Zombie Gold Riches"/>  
### **Encourages Team Collaboration and Shared Understanding**
The act of estimating has resulted in product discussion with developers about general scope and what they want to
accomplish from a requirements point of view. I think these processes cannot easily be replaced, but the acceptance testing
philosophy of defining requirements with tests could be one replacement. I don't think estimation need to be the main
input, but if they cause these discussions to happen that's probably a good thing.

### **Identifies Risks and Unknowns Early**
Identifying risks upfront or as early as possible is important. Funny enough, XP and scrum I think somewhat disagree on
requirements gathering. XP believes requirements are more incremental, whereas scrum believes a large part of these can
be determined beforehand. From what I've seen the latter is a bit of a pipe dream, but still the truth lies somewhere in
the middle of these two statements.

### **Helps Manage Scope Creep**
Scope in general is something I've been thinking of more lately. How do we properly identify all parts of this epic,
story, or ticket, so we don't end up in the trap of ever expanding scope creep. I've been the guy that picked up "just one task"
from the backlog only to discover it's a significant amount of work to implement in every library that requires the change.
I've seen overruns in general features countless times as well, but honestly the root cause of those overruns is not believing
the engineers when they give their honest estimate. Or perhaps not being willing to accept the answer.

## 5. Conclusion

As a previous business analyst, it became apparent fairly often my measurements were more about the discussion than the
numbers. Figuring out how to break down tasks properly, and divvy them out in a logical manner will keep developers, managers,
and customers alike happy. Hopefully more work in this area will reduce the divide between management and developers.
