<h1 id="aggregates-explained">Aggregates Explained</h1>

<h2 id="what-are-they-the-theory">What are they? The Theory</h2>

<p>An aggregates primary definition is that it has an id. It is used to grab information from the database, and controls
the flow in and out of the database through what is effectively a view.</p>

<h2 id="what-are-they-the-implementation">What are they? The Implementation</h2>

<p>The aggregate is implemented as the following:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public sealed class ExpenseReportAggregate
{
    [Key]
    private int Id { get; set; }

    private List&lt;Expenses&gt;? Expenses { get; set; }

    public List&lt;Expense&gt;? RetrieveExpenseList()
    {
        return Expenses?
            .Select(x =&gt; new Expense(x.ExpenseType, x.Amount))
            .ToList();
    }
}
</code></pre></div></div>
<p>The expenses should likely be privately set, as the setter should not be accessed externally. The aggregate is accessed through
the general Command/Query paradigm. The Repository layer takes these aggregates and either saves them or shows them in 
a view. This implementation for a view of the last expense report looks like the following:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class ExistingExpensesRepository
{
    private readonly ExpensesContext expensesContext;

    public ExistingExpensesRepository()
    {
        var DbPath = Path.Join(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "blogging.db");
        var dbContextOptions = new DbContextOptionsBuilder()
            .UseSqlite($"Data Source={DbPath}")
            .Options;
        expensesContext = new ExpensesContext(dbContextOptions);
    }

    public ExpenseReportAggregate? GetLastExpenseReport()
    {
        return expensesContext.ExpenseReportAggregates.ToList().LastOrDefault();
    }
}
</code></pre></div></div>

<p>The service is represented by the following code, which primarily just retrieves the aggregate from the repository layer,
does any domain work necessary, and then outputs it to the adapter(s).</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class ExpensesService
{
    private ExistingExpensesRepository expenseRepository;
    private readonly DateProvider dateProvider;

    // Used By Production Code, One Smoke Test
    public ExpensesService(DateProvider? dateProvider) {
        this.dateProvider = dateProvider ?? new RealDateProvider();
        expenseRepository = new ExistingExpensesRepository();
    }

    public ExpenseReport RetrieveExpenseReport() {
        var expensesReportAggregate = expenseRepository.GetLastExpenseReport();

        ExpenseReport expenseReport = new ExpenseReport(
            expensesReportAggregate?.RetrieveExpenseList() ?? new List&lt;Expense&gt;(),
            this.dateProvider);
        
        return expenseReport;
    }
}
</code></pre></div></div>
<p>Here the view expenses grabs the data from the repository in the form of an aggregate. It then takes this aggregate, constructs
the domain, does some calculations, and outputs a view.</p>

<p>The domain for the aggregate is, for example, calculating total expenses by doing the following:</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class ExpenseReport
{
    private List&lt;Expense&gt; expenses;

    public ExpenseReport(List&lt;Expense&gt; expenses) {
        this.expenses = expenses;
    }
    
    public int CalculateTotalExpenses() {
        int total = 0;
        foreach (Expense expense in expenses) {
            total += expense.Amount();
        }
        return total;
    }
}
</code></pre></div></div>

<p>I’m not convinced the repository layer is needed, as most of the work is done by the aggregate. I also don’t like how I 
constructed the domain.</p>

<p><a href="/blog_list.html">Take me to the blog</a></p>
